from typing import Dict, List, Tuple, Optional

import pandas as pd
import numpy as np
from skimage import measure
from scipy.spatial import distance
import matplotlib.pyplot as plt
from matplotlib.axes import Axes

from cell_abm_pipeline.initial_conditions.__config__ import (
    EDGE_THRESHOLD,
    CONNECTED_THRESHOLD,
    SCALE_MICRONS_XY,
    SCALE_MICRONS_Z,
)
from cell_abm_pipeline.initial_conditions.__main__ import Context
from cell_abm_pipeline.utilities.load import load_dataframe
from cell_abm_pipeline.utilities.save import save_dataframe, save_plot
from cell_abm_pipeline.utilities.keys import make_folder_key, make_file_key, make_full_key
from cell_abm_pipeline.utilities.plot import make_plot


class ProcessSamples:
    """
    Task to process samples with selected processing steps.

    Working location structure for a given context:

    .. code-block:: bash

        (name)
        ├── plots
        │    └── plots.SAMPLE
        │        ├── (name)_(image key 1).SAMPLE.png
        │        ├── (name)_(image key 2).SAMPLE.png
        │        ├── ...
        │        └── (name)_(image key n).SAMPLE.png
        └── samples
            ├── samples.PROCESSED
            │    ├── (name)_(image key 1).PROCESSED.csv
            │    ├── (name)_(image key 2).PROCESSED.csv
            │    ├── ...
            │    └── (name)_(image key n).PROCESSED.csv
            └── samples.RAW
                ├── (name)_(image key 1).RAW.csv
                ├── (name)_(image key 2).RAW.csv
                ├── ...
                └── (name)_(image key n).RAW.csv

    Samples to be processed are loaded from the **samples/samples.RAW**
    directory.
    If using this task after the sample images task, make sure image keys pass
    in include the appended channel value.
    Contact sheet plots from this task will overwrite existing contact sheets
    generated by the sample images task.

    Attributes
    ----------
    context
        **Context** object defining working location and name.
    folders
        Dictionary of input and output folder keys.
    files
        Dictionary of input and output file keys.
    """

    def __init__(self, context: Context):
        self.context = context
        self.folders = {
            "sample": make_folder_key(context.name, "samples", "RAW", False),
            "processed": make_folder_key(context.name, "samples", "PROCESSED", False),
            "contact": make_folder_key(context.name, "plots", "SAMPLE", False),
        }
        self.files = {
            "sample": make_file_key(context.name, ["RAW", "csv"], "%s", ""),
            "processed": make_file_key(context.name, ["PROCESSED", "csv"], "%s", ""),
            "contact": make_file_key(context.name, ["SAMPLE", "png"], "%s", ""),
        }

    def run(
        self,
        grid: str = "rect",
        scale: Optional[float] = None,
        include: Optional[List[int]] = None,
        exclude: Optional[List[int]] = None,
        edges: bool = False,
        connected: bool = False,
        contact: bool = True,
    ) -> None:
        """
        Runs process samples task for given context.

        Parameters
        ----------
        grid : {'rect', 'hex'}
            Type of sampling grid.
        scale
            Coordinate scaling factor.
        include
            Specific cell ids to include.
        exclude
            Specific cell ids to exclude.
        edges
            True if cells touching edges are removed, False otherwise.
        connected
            True if unconnected voxels are removed, False otherwise.
        contact
            True if contact sheet of images is saved, False otherwise.
        """
        for key in self.context.keys:
            self.process_samples(key, grid, scale, include, exclude, edges, connected)

            if contact:
                self.plot_contact_sheet(key)

    def process_samples(
        self,
        key: str,
        grid: str,
        scale: Optional[float],
        include: Optional[List[int]],
        exclude: Optional[List[int]],
        edges: bool,
        connected: bool,
    ) -> None:
        """
        Process samples task.

        Each selected processing task is applied to the list of samples, in the
        following order:

        1. Remove unconnected regions (if **connected** is True)
        2. Remove cells at the edge (if **edges** is True)
        3. Rescale sample coordinates (if **scale** is not None)
        4. Include samples for given cell ids (if **include** is not None)
        5. Exclude samples for given cell ids (if **exclude** is not None)

        Parameters
        ----------
        key
            Key for samples.
        grid : {'rect', 'hex'}
            Type of sampling grid.
        scale
            Coordinate scaling factor.
        include
            Specific cell ids to include.
        exclude
            Specific cell ids to exclude.
        edges
            True if cells touching edges are removed, False otherwise.
        connected
            True if unconnected voxels are removed, False otherwise.
        """
        sample_key = make_full_key(self.folders, self.files, "sample", key)
        raw_samples = load_dataframe(self.context.working, sample_key)
        processed_samples = raw_samples.copy()

        if connected:
            print("Removing unconnected regions ...")
            processed_samples = self.remove_unconnected_regions(processed_samples, grid)

        if edges:
            print("Removing edge cells ...")
            processed_samples = self.remove_edge_cells(processed_samples, grid)

        if scale is not None:
            print("Scaling coordinates ...")
            processed_samples = self.scale_coordinates(processed_samples, scale)

        if include:
            print("Including cell ids ...")
            processed_samples = self.include_cells(processed_samples, include)

        if exclude:
            print("Excluding cell ids ...")
            processed_samples = self.exclude_cells(processed_samples, exclude)

        processed_key = make_full_key(self.folders, self.files, "processed", key)
        save_dataframe(self.context.working, processed_key, processed_samples, index=False)

    def plot_contact_sheet(self, key: str) -> None:
        """
        Plot contact sheet for processed samples.

        Parameters
        ----------
        key
            Key for samples.
        """
        sample_key = make_full_key(self.folders, self.files, "sample", key)
        sample_data = load_dataframe(self.context.working, sample_key)

        processed_key = make_full_key(self.folders, self.files, "processed", key)
        processed_data = load_dataframe(self.context.working, processed_key)

        data = {"samples": sample_data, "processed": processed_data}
        make_plot(sorted(data["samples"].z.unique()), data, self.plot_contact_sheet_axes)

        plt.gca().invert_yaxis()
        plot_key = make_full_key(self.folders, self.files, "contact", key)
        save_plot(self.context.working, plot_key)

    @staticmethod
    def plot_contact_sheet_axes(ax: Axes, data: Dict[str, pd.DataFrame], key: int) -> None:
        """
        Plot samples for selected z index, colored by id with removed samples in gray.

        Parameters
        ----------
        ax
            **Axes** instance to plot on.
        data
            Raw and processed samples.
        key
            Index of z slice to plot.
        """
        samples = data["samples"]
        processed = data["processed"]
        filtered = pd.merge(samples, processed, how="outer", indicator=True)
        removed = filtered[filtered["_merge"] == "left_only"]

        z_slice = processed[processed.z == key]
        z_removed = removed[removed.z == key]

        max_id = int(samples.id.max())
        min_id = int(samples.id.min())

        ax.scatter(z_slice.x, z_slice.y, c=z_slice.id, vmin=min_id, vmax=max_id, s=1, cmap="jet")
        ax.scatter(z_removed.x, z_removed.y, s=0.5, c="#ccc")
        ax.set_aspect("equal", adjustable="box")

    @staticmethod
    def scale_coordinates(
        samples: pd.DataFrame,
        scale_factor: float,
        scale_xy: float = SCALE_MICRONS_XY,
        scale_z: float = SCALE_MICRONS_Z,
    ) -> pd.DataFrame:
        """
        Scales (x, y, z) coordinates in sample by scaling factor.

        The x and y coordinates are additionally scaled by x/y resolution.
        The z coordinates are additionally scaled z resolution.

        Parameters
        ----------
        samples
            Sample cell ids and coordinates.
        scale_factor
            Coordinate scaling factor.
        scale_xy
            Resolution scaling in x/y, default = ``SCALE_MICRONS_XY``.
        scale_z
            Resolution scaling in z, default = ``SCALE_MICRONS_Z``.

        Returns
        -------
        :
            Samples with scaled coordinates.
        """
        samples["x_scaled"] = samples.x * scale_factor * scale_xy
        samples["y_scaled"] = samples.y * scale_factor * scale_xy
        samples["z_scaled"] = samples.z * scale_factor * scale_z
        return samples

    @staticmethod
    def include_cells(samples: pd.DataFrame, include: List[int]) -> pd.DataFrame:
        """
        Filters samples to include given ids.

        Parameters
        ----------
        samples
            Sample cell ids and coordinates.
        include
            List of ids to include.

        Returns
        -------
        :
            Samples with included ids.
        """
        samples = samples[samples.id.isin(include)]
        return samples.reset_index(drop=True)

    @staticmethod
    def exclude_cells(samples: pd.DataFrame, exclude: List[int]) -> pd.DataFrame:
        """
        Filters samples to exclude given ids.

        Parameters
        ----------
        samples
            Sample cell ids and coordinates.
        exclude
            List of ids to exclude.

        Returns
        -------
        :
            Samples without excluded ids.
        """
        samples = samples[~samples.id.isin(exclude)]
        return samples.reset_index(drop=True)

    @staticmethod
    def remove_edge_cells(
        samples: pd.DataFrame, grid: str = "rect", edge_threshold: float = EDGE_THRESHOLD
    ) -> pd.DataFrame:
        """
        Removes cells at edges.

        Parameters
        ----------
        samples
            Sample cell ids and coordinates.
        grid : {'rect', 'hex'}
            Type of sampling grid.
        edge_threshold
            Number of edge voxels to assign edge cell, default = ``EDGE_THRESHOLD``.

        Returns
        -------
        :
            Samples with edge cells removed.
        """

        # Get edge padding.
        x_padding = ProcessSamples.get_step_size(samples.x) if grid == "hex" else 0
        y_padding = ProcessSamples.get_step_size(samples.y) if grid == "hex" else 0

        # Get ids of cell at edge.
        x_edge_ids = ProcessSamples.find_edge_ids("x", samples, x_padding, edge_threshold)
        y_edge_ids = ProcessSamples.find_edge_ids("y", samples, y_padding, edge_threshold)

        # Filter samples for cells not at edge.
        all_edge_ids = set(x_edge_ids + y_edge_ids)
        samples_filtered = samples[~samples["id"].isin(all_edge_ids)]

        return samples_filtered.reset_index(drop=True)

    @staticmethod
    def remove_unconnected_regions(
        samples: pd.DataFrame, grid: str, connected_threshold: float = CONNECTED_THRESHOLD
    ) -> pd.DataFrame:
        """
        Removes unconnected regions of cells.

        Parameters
        ----------
        samples
            Sample cell ids and coordinates.
        grid : {'rect', 'hex'}
            Type of sampling grid.
        connected_threshold
            Distance for removing unconnected regions, default = ``CONNECTED_THRESHOLD``.

        Returns
        -------
        :
            Samples with unconnected regions removed.
        """

        if grid == "rect":
            return ProcessSamples.remove_unconnected_by_connectivity(samples)

        if grid == "hex":
            return ProcessSamples.remove_unconnected_by_distance(samples, connected_threshold)

        raise ValueError(f"invalid grid type {grid}")

    @staticmethod
    def remove_unconnected_by_connectivity(samples: pd.DataFrame) -> pd.DataFrame:
        """
        Removes unconnected regions based on simple connectivity.

        Parameters
        ----------
        samples
            Sample cell ids and coordinates.

        Returns
        -------
        :
            Samples with unconnected regions removed.
        """
        steps = ProcessSamples.get_step_sizes(samples)
        minimums = ProcessSamples.get_sample_minimums(samples)
        maximums = ProcessSamples.get_sample_maximums(samples)

        array = ProcessSamples.convert_to_integer_array(samples, steps, minimums, maximums)

        array_connected = np.zeros(array.shape, dtype="int")
        labels = measure.label(array, connectivity=1)

        # Sort labeled regions by size.
        regions = np.bincount(labels.flatten())[1:]
        regions_sorted = sorted(
            [(i + 1, n) for i, n in enumerate(regions)],
            key=lambda tup: tup[1],
            reverse=True,
        )

        # Iterate through all regions and copy the largest connected region to array.
        ids_added = set()
        for index, _ in regions_sorted:
            cell_id = list(set(array[labels == index]))[0]

            if cell_id not in ids_added:
                array_connected[labels == index] = cell_id
                ids_added.add(cell_id)
            else:
                print(f"Skipping unconnected region for cell id {cell_id}")

        # Convert back to dataframe.
        samples_connected = ProcessSamples.convert_to_dataframe(array_connected, steps, minimums)
        return samples_connected.sort_values(by=["id", "x", "y", "z"]).reset_index(drop=True)

    @staticmethod
    def remove_unconnected_by_distance(samples: pd.DataFrame, threshold: float) -> pd.DataFrame:
        """
        Removes unconnected regions based on distance.

        Parameters
        ----------
        samples
            Sample cell ids and coordinates.
        threshold
            Distance for removing unconnected regions.

        Returns
        -------
        :
            Samples with unconnected regions removed.
        """
        all_connected: List = []

        # Iterate through each id and filter out samples above the distance threshold.
        for cell_id, group in samples.groupby("id"):
            coordinates = group[["x", "y", "z"]].to_numpy()
            distances = [
                ProcessSamples.get_minimum_distance(np.array([coordinate]), coordinates)
                for coordinate in coordinates
            ]
            connected = [
                (cell_id, x, y, z)
                for distance, (x, y, z) in zip(distances, coordinates)
                if distance < threshold
            ]
            all_connected = all_connected + connected

        # Convert back to dataframe.
        samples_connected = pd.DataFrame(all_connected, columns=["id", "x", "y", "z"])
        return samples_connected.sort_values(by=["id", "x", "y", "z"]).reset_index(drop=True)

    @staticmethod
    def get_step_sizes(samples: pd.DataFrame) -> Tuple[int, int, int]:
        """
        Gets step sizes in x, y, and z directions for samples.

        Parameters
        ----------
        samples
            Sample cell ids and coordinates.

        Returns
        -------
        :
            Tuple of step sizes.
        """
        step_x = ProcessSamples.get_step_size(samples.x)
        step_y = ProcessSamples.get_step_size(samples.y)
        step_z = ProcessSamples.get_step_size(samples.z)
        step_sizes = (step_x, step_y, step_z)
        return step_sizes

    @staticmethod
    def get_step_size(entries: List[int]) -> int:
        """
        Gets step size between ordered entries.

        For arrays with multiple step sizes, the most common step size is
        returned.

        Parameters
        ----------
        entries
            List of entries.

        Returns
        -------
        :
            Step size between entries.
        """
        unique = sorted(list(set(entries)))
        steps = [j - i for i, j in zip(unique[:-1], unique[1:])]
        step = set(steps)

        if len(step) > 1:
            print("WARNING: variable step size in array")

        return max(set(step), key=steps.count)

    @staticmethod
    def get_sample_minimums(samples: pd.DataFrame) -> Tuple[int, int, int]:
        """
        Gets minimums in x, y, and z directions for samples.

        Parameters
        ----------
        samples
            Sample cell ids and coordinates.

        Returns
        -------
            Tuple of minimums.
        """
        min_x = min(samples.x)
        min_y = min(samples.y)
        min_z = min(samples.z)
        minimums = (min_x, min_y, min_z)
        return minimums

    @staticmethod
    def get_sample_maximums(samples: pd.DataFrame) -> Tuple[int, int, int]:
        """
        Gets maximums in x, y, and z directions for samples.

        Parameters
        ----------
        samples
            Sample cell ids and coordinates.

        Returns
        -------
            Tuple of maximums.
        """
        max_x = max(samples.x)
        max_y = max(samples.y)
        max_z = max(samples.z)
        maximums = (max_x, max_y, max_z)
        return maximums

    @staticmethod
    def find_edge_ids(
        axis: str, samples: pd.DataFrame, padding: float, threshold: float
    ) -> List[int]:
        """
        Finds ids of cells with voxels touching edges of given axis.

        Parameters
        ----------
        axis : {'x', 'y', 'z'}
            The name of axis to check.
        samples
            Sample cell ids and coordinates.
        padding
            Distance from axis limits to assign edge voxels.
        threshold
            Number of edge voxels to assign edge cell.

        Returns
        -------
        :
            List of edge cell ids.
        """

        # Get min and max coordinate for given axis.
        axis_min = samples[axis].min() + padding
        axis_max = samples[axis].max() - padding

        # Check for cell ids located at edges.
        edges = samples.groupby("id").apply(
            lambda g: len(g[(g[axis] <= axis_min) | (g[axis] >= axis_max)])
        )
        edge_ids = edges[edges > threshold]

        return list(edge_ids.index)

    @staticmethod
    def convert_to_integer_array(
        samples: pd.DataFrame,
        steps: Tuple[int, int, int],
        minimums: Tuple[int, int, int],
        maximums: Tuple[int, int, int],
    ) -> np.ndarray:
        """
        Converts ids and coordinate samples to integer array.

        Parameters
        ----------
        samples
            Sample cell ids and coordinates.
        steps
            Step sizes in x, y, and z directions.
        minimums
            Minimums in x, y, and z directions.
        maximums
            Maximums in x, y, and z directions.

        Returns
        -------
        :
            Array of ids.
        """
        length, width, height = np.divide(np.subtract(maximums, minimums), steps).astype("int32")
        array = np.zeros((height + 1, width + 1, length + 1), dtype="int32")

        coordinates = (samples[["x", "y", "z"]].values - minimums) / steps
        coordinates = coordinates.astype("int32")
        array[tuple(np.transpose(np.flip(coordinates, axis=1)))] = samples.id

        return array

    @staticmethod
    def convert_to_dataframe(
        array: np.ndarray, steps: Tuple[int, int, int], minimums: Tuple[int, int, int]
    ) -> pd.DataFrame:
        """
        Converts integer array to ids and coordinate samples.

        Parameters
        ----------
        array
            Integer array of ids.
        steps
            Step sizes in x, y, and z directions.
        minimums
            Minimums in x, y, and z directions.

        Returns
        -------
        :
            Dataframe of ids and coordinates.
        """
        step_x, step_y, step_z = steps
        min_x, min_y, min_z = minimums

        samples = [
            (
                array[z, y, x],
                (x * step_x) + min_x,
                (y * step_y) + min_y,
                (z * step_z) + min_z,
            )
            for z, y, x in zip(*np.where(array != 0))
        ]

        return pd.DataFrame(samples, columns=["id", "x", "y", "z"])

    @staticmethod
    def get_minimum_distance(source: np.ndarray, targets: np.ndarray) -> float:
        """
        Get the minimum distance from point to array of points.

        Parameters
        ----------
        source
            Coordinates of source point with shape (1, 3)
        targets
            Coordinates for N target points with shape (3, N)

        Returns
        -------
        :
            Minimum distance between source and targets.
        """
        distances = distance.cdist(source, targets)
        return np.min(distances[distances != 0])
