from typing import Dict, List, Optional

import pandas as pd
import numpy as np
from skimage import measure
from scipy.spatial import distance
import matplotlib.pyplot as plt
from matplotlib.axes import Axes

from cell_abm_pipeline.initial_conditions.__config__ import (
    EDGE_THRESHOLD,
    CONNECTED_THRESHOLD,
    SCALE_MICRONS_XY,
    SCALE_MICRONS_Z,
)
from cell_abm_pipeline.initial_conditions.__main__ import Context
from cell_abm_pipeline.utilities.load import load_dataframe
from cell_abm_pipeline.utilities.save import save_dataframe, save_plot
from cell_abm_pipeline.utilities.keys import make_folder_key, make_file_key, make_full_key
from cell_abm_pipeline.utilities.plot import make_plot


class ProcessSamples:
    """
    Task to process samples with selected processing steps

    Working location structure for a given context:

    .. code-block:: bash

        (name)
        ├── plots
        │    └── plots.SAMPLE
        │        ├── (name)_(image key 1).SAMPLE.png
        │        ├── (name)_(image key 2).SAMPLE.png
        │        ├── ...
        │        └── (name)_(image key n).SAMPLE.png
        └── samples
            ├── samples.PROCESSED
            │    ├── (name)_(image key 1).PROCESSED.csv
            │    ├── (name)_(image key 2).PROCESSED.csv
            │    ├── ...
            │    └── (name)_(image key n).PROCESSED.csv
            └── samples.RAW
                ├── (name)_(image key 1).RAW.csv
                ├── (name)_(image key 2).RAW.csv
                ├── ...
                └── (name)_(image key n).RAW.csv

    Samples to be processed are loaded from the **samples/samples.RAW**
    directory.
    If using this task after the sample images task, make sure image keys pass
    in include the appended channel value.
    Contact sheet plots from this task will overwrite existing contact sheets
    generated by the sample images task.

    Attributes
    ----------
    context
        **Context** object defining working location and name.
    folders
        Dictionary of input and output folder keys.
    files
        Dictionary of input and output file keys.
    """

    def __init__(self, context: Context):
        self.context = context
        self.folders = {
            "sample": make_folder_key(context.name, "samples", "RAW", False),
            "processed": make_folder_key(context.name, "samples", "PROCESSED", False),
            "contact": make_folder_key(context.name, "plots", "SAMPLE", False),
        }
        self.files = {
            "sample": make_file_key(context.name, ["RAW", "csv"], "%s", ""),
            "processed": make_file_key(context.name, ["PROCESSED", "csv"], "%s", ""),
            "contact": make_file_key(context.name, ["SAMPLE", "png"], "%s", ""),
        }

    def run(
        self,
        grid: str = "rect",
        scale: Optional[float] = None,
        select: Optional[List[int]] = None,
        edges: bool = False,
        connected: bool = False,
        contact: bool = True,
    ) -> None:
        """
        Runs process samples task for given context.

        Parameters
        ----------
        grid : {'rect', 'hex'}
            Type of sampling grid.
        scale
            Coordinate scaling factor.
        select
            Specific cell ids to select
        edges
            True if cells touching edges are removed, False otherwise.
        connected
            True if unconnected voxels are removed, False otherwise.
        contact
            True if contact sheet of images is saved, False otherwise.
        """
        for key in self.context.keys:
            self.process_samples(key, grid, scale, select, edges, connected)

            if contact:
                self.plot_contact_sheet(key)

    def process_samples(
        self,
        key: str,
        grid: str,
        scale: Optional[float],
        select: Optional[List[int]],
        edges: bool,
        connected: bool,
    ) -> None:
        """
        Process samples task.

        Each selected processing task is applied to the list of samples, in the
        following order:

        1. Remove unconnected regions (if **connected** is True)
        2. Remove cells at the edge (if **edges** is True)
        3. Rescale sample coordinates (if **scale** is not None)
        4. Select only samples for given cell ids (if **select** is not None)

        Parameters
        ----------
        key
            Key for samples.
        grid : {'rect', 'hex'}
            Type of sampling grid.
        scale
            Coordinate scaling factor.
        select
            Specific cell ids to select
        edges
            True if cells touching edges are removed, False otherwise.
        connected
            True if unconnected voxels are removed, False otherwise.
        """
        sample_key = make_full_key(self.folders, self.files, "sample", key)
        raw_samples = load_dataframe(self.context.working, sample_key)
        processed_samples = raw_samples.copy()

        if connected:
            print("Removing unconnected regions ...")
            processed_samples = self.remove_unconnected_regions(processed_samples, grid)

        if edges:
            print("Removing edge cells ...")
            processed_samples = self.remove_edge_cells(processed_samples, grid)

        if scale is not None:
            print("Scaling coordinates ...")
            processed_samples = self.scale_coordinates(processed_samples, scale)

        if select:
            print("Selecting cell ids ...")
            processed_samples = self.select_cells(processed_samples, select)

        processed_key = make_full_key(self.folders, self.files, "processed", key)
        save_dataframe(self.context.working, processed_key, processed_samples, index=False)

    def plot_contact_sheet(self, key: str) -> None:
        """
        Plot contact sheet for processed samples.

        Parameters
        ----------
        key
            Key for samples.
        """
        sample_key = make_full_key(self.folders, self.files, "sample", key)
        sample_data = load_dataframe(self.context.working, sample_key)

        processed_key = make_full_key(self.folders, self.files, "processed", key)
        processed_data = load_dataframe(self.context.working, processed_key)

        data = {"samples": sample_data, "processed": processed_data}
        make_plot(sorted(data["samples"].z.unique()), data, self.plot_contact_sheet_axes)

        plt.gca().invert_yaxis()
        plot_key = make_full_key(self.folders, self.files, "contact", key)
        save_plot(self.context.working, plot_key)

    @staticmethod
    def plot_contact_sheet_axes(ax: Axes, data: Dict[str, pd.DataFrame], key: int) -> None:
        """
        Plot samples for selected z index, colored by id with removed samples in gray.

        Parameters
        ----------
        ax
            **Axes** instance to plot on.
        data
            Raw and processed samples.
        key
            Index of z slice to plot.
        """
        samples = data["samples"]
        processed = data["processed"]
        filtered = pd.merge(samples, processed, how="outer", indicator=True)
        removed = filtered[filtered["_merge"] == "left_only"]

        z_slice = processed[processed.z == key]
        z_removed = removed[removed.z == key]

        max_id = int(samples.id.max())
        min_id = int(samples.id.min())

        ax.scatter(z_slice.x, z_slice.y, c=z_slice.id, vmin=min_id, vmax=max_id, s=1, cmap="jet")
        ax.scatter(z_removed.x, z_removed.y, s=0.5, c="#ccc")
        ax.set_aspect("equal", adjustable="box")

    @staticmethod
    def scale_coordinates(samples, scale_factor):
        samples["x_scaled"] = samples.x * SCALE_MICRONS_XY * scale_factor
        samples["y_scaled"] = samples.y * SCALE_MICRONS_XY * scale_factor
        samples["z_scaled"] = samples.z * SCALE_MICRONS_Z * scale_factor
        return samples

    @staticmethod
    def select_cells(samples, select):
        samples = samples[samples.id.isin(select)]
        return samples

    @staticmethod
    def remove_edge_cells(samples, grid="rect", edge_threshold=EDGE_THRESHOLD):
        """Removes cells at edges of FOV."""

        # Get edge padding.
        x_padding = ProcessSamples.get_step_size(samples.x) if grid == "hex" else 0
        y_padding = ProcessSamples.get_step_size(samples.y) if grid == "hex" else 0

        # Get ids of cell at edge.
        x_edge_ids = ProcessSamples.find_edge_ids("x", samples, x_padding, edge_threshold)
        y_edge_ids = ProcessSamples.find_edge_ids("y", samples, y_padding, edge_threshold)

        # Filter samples for cells not at edge.
        all_edge_ids = set(x_edge_ids + y_edge_ids)
        samples_filtered = samples[~samples["id"].isin(all_edge_ids)]

        return samples_filtered

    @staticmethod
    def remove_unconnected_regions(samples, grid, connected_threshold=CONNECTED_THRESHOLD):
        """Removes unconnected regions of cells."""
        if grid == "rect":
            return ProcessSamples.remove_unconnected_by_connectivity(samples)

        if grid == "hex":
            return ProcessSamples.remove_unconnected_by_distance(samples, connected_threshold)

        raise ValueError(f"invalid grid type {grid}")

    @staticmethod
    def remove_unconnected_by_connectivity(samples):
        """Removes unconnected regions based on connectivity."""

        arr, steps, offsets = ProcessSamples.convert_to_integer_array(samples)
        arr_conn = np.zeros(arr.shape, dtype="int")
        labels = measure.label(arr, connectivity=1)

        # Sort labeled regions by size.
        regions = np.bincount(labels.flatten())[1:]
        regions_sorted = sorted(
            [(i + 1, n) for i, n in enumerate(regions)],
            key=lambda tup: tup[1],
            reverse=True,
        )

        # Iterate through all regions and copy largest connected region to array.
        ids_added = set()
        for index, _ in regions_sorted:
            cell_id = list(set(arr[labels == index]))[0]

            if cell_id not in ids_added:
                arr_conn[labels == index] = cell_id
                ids_added.add(cell_id)
            else:
                print(f"Skipping unconnected region for cell id {cell_id}")

        # Convert back to dataframe.
        samples_connected = ProcessSamples.convert_to_dataframe(arr_conn, steps, offsets)

        return samples_connected

    @staticmethod
    def remove_unconnected_by_distance(samples, threshold):
        """Removes unconnected regions based on distance."""
        all_connected = []

        # Rescale coordinates to um.
        samples["xs"] = samples.x * SCALE_MICRONS_XY
        samples["ys"] = samples.y * SCALE_MICRONS_XY
        samples["zs"] = samples.z * SCALE_MICRONS_Z

        # Iterate through each id and filter out samples above the distance threshold.
        for name, group in samples.groupby("id"):
            coords = group[["x", "y", "z", "xs", "ys", "zs"]].to_numpy()
            dists = [
                [ProcessSamples.get_minimum_distance(c[3:], coords[:, 3:]), *c[:3]] for c in coords
            ]
            connected = [[name, x, y, z] for d, x, y, z in dists if d < threshold]
            all_connected = all_connected + connected

        if len(all_connected) == 0:
            print("WARNING: no connected samples, try increasing connected threshold")
            return pd.DataFrame()

        # Convert back to dataframe.
        samples_connected = pd.DataFrame(all_connected, columns=["id", "x", "y", "z"], dtype=int)

        return samples_connected

    @staticmethod
    def get_step_size(arr):
        """Gets step size between array entries."""

        # Get steps between subsequent unique entries in array.
        unique = sorted(arr.unique())
        steps = [j - i for i, j in zip(unique[:-1], unique[1:])]
        step = set(steps)

        if len(step) > 1:
            print("WARNING: variable step size in array")

        return max(set(step), key=steps.count)

    @staticmethod
    def find_edge_ids(axis, samples, padding, threshold):
        """Finds ids of cells at edges of given axis."""

        # Get min and max coordinate for given axis.
        axis_min = samples[axis].min() + padding
        axis_max = samples[axis].max() - padding

        # Check for cell ids located at edges.
        edges = samples.groupby("id").apply(
            lambda g: len(g[(g[axis] <= axis_min) | (g[axis] >= axis_max)])
        )
        edge_ids = edges[edges > threshold]

        return list(edge_ids.index)

    @staticmethod
    def convert_to_integer_array(samples):
        """Converts dataframe of voxels into integer array."""

        # Get step size for voxels.
        step_x = ProcessSamples.get_step_size(samples.x)
        step_y = ProcessSamples.get_step_size(samples.y)
        step_z = ProcessSamples.get_step_size(samples.z)

        # Rescale integers to step size 1.
        scaled_x = samples.x.divide(step_x).astype("int32").values
        scaled_y = samples.y.divide(step_y).astype("int32").values
        scaled_z = samples.z.divide(step_z).astype("int32").values

        # Create integer array.
        offset_x = min(scaled_x)
        offset_y = min(scaled_y)
        offset_z = min(scaled_z)
        length = max(scaled_x) - offset_x + 1
        width = max(scaled_y) - offset_y + 1
        height = max(scaled_z) - offset_z + 1
        arr = np.zeros((height, width, length), dtype="int32")

        # Populate array.
        for x, y, z, i in zip(scaled_x, scaled_y, scaled_z, samples.id):
            arr[z - offset_z, y - offset_y, x - offset_x] = i

        return arr, [step_x, step_y, step_z], [offset_x, offset_y, offset_z]

    @staticmethod
    def convert_to_dataframe(arr, steps, offsets):
        step_x, step_y, step_z = steps
        offset_x, offset_y, offset_z = offsets

        voxels = [
            (
                arr[z, y, x],
                step_x * (x + offset_x),
                step_y * (y + offset_y),
                step_z * (z + offset_z),
            )
            for z, y, x in zip(*np.where(arr != 0))
        ]

        return pd.DataFrame(voxels, columns=["id", "x", "y", "z"])

    @staticmethod
    def get_minimum_distance(point, points):
        """Get minimum distance of point to array of points."""
        dists = distance.cdist([point], points)
        return np.min(dists[dists != 0])
